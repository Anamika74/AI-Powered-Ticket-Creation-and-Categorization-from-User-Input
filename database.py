import sqlite3
from datetime import datetime
import uuid

# Initialize the database and create tables
def init_db():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    # Requirement 2: Fields for id, title, desc, category, priority, status, and time
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS tickets (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ticket_id TEXT UNIQUE,
            user_id TEXT NOT NULL,
            user_name TEXT,
            title TEXT,
            description TEXT NOT NULL,
            category TEXT,
            priority TEXT,
            status TEXT DEFAULT 'Open',
            created_at TIMESTAMP
        )
    ''')
    
    # Migration: Add missing columns for existing databases
    cursor.execute("PRAGMA table_info(tickets)")
    columns = [column[1] for column in cursor.fetchall()]
    
    # Add ticket_id column if it doesn't exist
    if 'ticket_id' not in columns:
        try:
            cursor.execute("ALTER TABLE tickets ADD COLUMN ticket_id TEXT")
            # Populate existing rows with generated ticket IDs
            cursor.execute("SELECT id, created_at FROM tickets WHERE ticket_id IS NULL")
            rows = cursor.fetchall()
            for row_id, created_at in rows:
                if created_at:
                    try:
                        dt = datetime.strptime(str(created_at), '%Y-%m-%d %H:%M:%S.%f')
                    except:
                        dt = datetime.strptime(str(created_at), '%Y-%m-%d %H:%M:%S')
                    ticket_id = f"TIC-{dt.strftime('%H%M%S')}"
                else:
                    ticket_id = f"TIC-{datetime.now().strftime('%H%M%S')}"
                cursor.execute("UPDATE tickets SET ticket_id = ? WHERE id = ?", (ticket_id, row_id))
        except Exception as e:
            pass  # Column might already exist
    
    # Add title column if it doesn't exist
    if 'title' not in columns:
        try:
            cursor.execute("ALTER TABLE tickets ADD COLUMN title TEXT")
        except Exception as e:
            pass  # Column might already exist
    
    conn.commit()
    conn.close()

# Save a new ticket generated by the AI
def add_ticket(user_id, user_name, title, description, category, priority):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    # Generate ticket ID in format TIC-HHMMSS
    ticket_id = f"TIC-{datetime.now().strftime('%H%M%S')}"
    # Requirement 3: Storing tickets so they don't disappear on refresh
    cursor.execute('''
        INSERT INTO tickets (ticket_id, user_id, user_name, title, description, category, priority, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (ticket_id, user_id, user_name, title, description, category, priority, datetime.now()))
    conn.commit()
    conn.close()
    return ticket_id

# Fetch tickets for a specific user or all tickets for Admin
def get_tickets(user_id=None):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    # Select columns in specific order: id, ticket_id, user_id, user_name, title, description, category, priority, status, created_at
    if user_id:
        cursor.execute("SELECT id, ticket_id, user_id, user_name, title, description, category, priority, status, created_at FROM tickets WHERE user_id = ? ORDER BY created_at DESC", (user_id,))
    else:
        cursor.execute("SELECT id, ticket_id, user_id, user_name, title, description, category, priority, status, created_at FROM tickets ORDER BY created_at DESC")
    data = cursor.fetchall()
    conn.close()
    return data

# Requirement 4 & 6: Update Ticket Status via Dropdown
def update_status(ticket_id, new_status):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("UPDATE tickets SET status = ? WHERE id = ?", (new_status, ticket_id))
    conn.commit()
    conn.close()

# Delete a ticket (Admin/Support only, not General Users)
def delete_ticket(ticket_id):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("DELETE FROM tickets WHERE id = ?", (ticket_id,))
    conn.commit()
    conn.close()

# Auto-close resolved tickets after 24 hours
def auto_close_resolved():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    # Find tickets resolved more than 24 hours ago and close them
    cursor.execute("""
        UPDATE tickets 
        SET status = 'Closed' 
        WHERE status = 'Resolved' 
        AND datetime(created_at) <= datetime('now', '-24 hours')
    """)
    conn.commit()
    conn.close()

# Get ticket by ID
def get_ticket_by_id(ticket_id):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("SELECT id, ticket_id, user_id, user_name, title, description, category, priority, status, created_at FROM tickets WHERE id = ?", (ticket_id,))
    data = cursor.fetchone()
    conn.close()
    return data

# --- FEEDBACK MANAGEMENT ---
# Create feedback table
def init_feedback_table():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT,
            user_name TEXT,
            email TEXT,
            feedback_type TEXT,
            message TEXT,
            rating INTEGER,
            created_at TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

# Save feedback
def add_feedback(user_id, user_name, email, feedback_type, message, rating):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO feedback (user_id, user_name, email, feedback_type, message, rating, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (user_id, user_name, email, feedback_type, message, rating, datetime.now()))
    conn.commit()
    conn.close()

# Get all feedback for admin
def get_all_feedback():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("SELECT id, user_id, user_name, email, feedback_type, message, rating, created_at FROM feedback ORDER BY created_at DESC")
    data = cursor.fetchall()
    conn.close()
    return data

# --- TICKET COMMENTS SYSTEM ---
def init_comments_table():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS ticket_comments (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ticket_id TEXT,
            user_id TEXT,
            user_name TEXT,
            comment TEXT,
            is_internal INTEGER DEFAULT 0,
            created_at TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

def add_comment(ticket_id, user_id, user_name, comment, is_internal=0):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO ticket_comments (ticket_id, user_id, user_name, comment, is_internal, created_at)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (ticket_id, user_id, user_name, comment, is_internal, datetime.now()))
    conn.commit()
    conn.close()

def get_ticket_comments(ticket_id):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("SELECT id, user_id, user_name, comment, is_internal, created_at FROM ticket_comments WHERE ticket_id = ? ORDER BY created_at ASC", (ticket_id,))
    data = cursor.fetchall()
    conn.close()
    return data

# --- USER PREFERENCES ---
def init_preferences_table():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_preferences (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT UNIQUE,
            theme TEXT DEFAULT 'dark',
            email_notifications INTEGER DEFAULT 1,
            created_at TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

def get_user_preferences(user_id):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("SELECT theme, email_notifications FROM user_preferences WHERE user_id = ?", (user_id,))
    data = cursor.fetchone()
    conn.close()
    return data if data else ('dark', 1)

def update_user_preferences(user_id, theme, email_notifications):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT OR REPLACE INTO user_preferences (user_id, theme, email_notifications, created_at)
        VALUES (?, ?, ?, ?)
    ''', (user_id, theme, email_notifications, datetime.now()))
    conn.commit()
    conn.close()

# --- MODEL FEEDBACK TRACKING ---
def init_model_feedback_table():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS model_feedback (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ticket_id TEXT,
            predicted_category TEXT,
            actual_category TEXT,
            confidence REAL,
            feedback_type TEXT,
            created_at TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

def add_model_feedback(ticket_id, predicted_category, actual_category, confidence, feedback_type='misclassification'):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO model_feedback (ticket_id, predicted_category, actual_category, confidence, feedback_type, created_at)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (ticket_id, predicted_category, actual_category, confidence, feedback_type, datetime.now()))
    conn.commit()
    conn.close()

def get_model_feedback_stats():
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) as total, COUNT(DISTINCT ticket_id) as unique_tickets FROM model_feedback")
    data = cursor.fetchone()
    conn.close()
    return data

# --- SEARCH & ADVANCED FILTERING ---
def search_tickets(search_query, filters=None):
    """Search tickets by title, description, or category"""
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    
    query = "SELECT id, ticket_id, user_id, user_name, title, description, category, priority, status, created_at FROM tickets WHERE "
    params = []
    
    # Search term
    query += "(title LIKE ? OR description LIKE ? OR category LIKE ?)"
    search_param = f"%{search_query}%"
    params.extend([search_param, search_param, search_param])
    
    # Additional filters
    if filters:
        if 'status' in filters and filters['status']:
            query += " AND status IN ({})".format(','.join(['?' for _ in filters['status']]))
            params.extend(filters['status'])
        if 'category' in filters and filters['category']:
            query += " AND category IN ({})".format(','.join(['?' for _ in filters['category']]))
            params.extend(filters['category'])
        if 'date_from' in filters and filters['date_from']:
            query += " AND created_at >= ?"
            params.append(filters['date_from'])
        if 'date_to' in filters and filters['date_to']:
            query += " AND created_at <= ?"
            params.append(filters['date_to'])
    
    query += " ORDER BY created_at DESC"
    cursor.execute(query, params)
    data = cursor.fetchall()
    conn.close()
    return data

# --- PRIORITY OVERRIDE ---
def update_priority(ticket_id, new_priority):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    cursor.execute("UPDATE tickets SET priority = ? WHERE id = ?", (new_priority, ticket_id))
    conn.commit()
    conn.close()

# --- BULK OPERATIONS ---
def bulk_update_status(ticket_ids, new_status):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    placeholders = ','.join(['?' for _ in ticket_ids])
    cursor.execute(f"UPDATE tickets SET status = ? WHERE id IN ({placeholders})", [new_status] + ticket_ids)
    conn.commit()
    conn.close()

def bulk_delete(ticket_ids):
    conn = sqlite3.connect('service_desk.db')
    cursor = conn.cursor()
    placeholders = ','.join(['?' for _ in ticket_ids])
    cursor.execute(f"DELETE FROM tickets WHERE id IN ({placeholders})", ticket_ids)
    conn.commit()
    conn.close()